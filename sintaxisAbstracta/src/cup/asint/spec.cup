package asint;

import java_cup.runtime.*;
import cup.alex.AnalizadorLexicoTiny;
import cup.alex.UnidadLexica;
import cup.errors.GestionErroresTiny;

scan with {: 
  return getScanner().next_token(); 
:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};
action code {:
  ClaseSemanticaEval sem = new ClaseSemanticaEval();
:}

terminal INIBLOQUE, FINBLOQUE, FINDECLARACIONES, PUNTOYCOMA, PUNTO, INIPAR, FINPAR, INIARRAY, FINARRAY, PUNTERO, REFERENCIA, COMA, ARROBA, MAYOR, MAYORIGUAL, MENOR, MENORIGUAL, COMPARACION, DISTINTO, ASIGNACION, POR, ENTRE, AND, OR, MODULO, NOT, MAS, MENOS, IF, ELSE, WHILE, READ, WRITE, NL, NEW, DELETE, CALL, INT, REAL, BOOL, STRING, STRUCT, TYPE, PROC, TRUE, FALSE, NULL;
terminal StringLocalizado Identificador, Entero, Real, Cadena;

non terminal  ProgT programa_tiny;
non terminal  Blq bloque;
non terminal  LOptDecs lista_opt_declaraciones;
non terminal  LDecs lista_declaraciones;
non terminal  Dec declaracion, declaracion_variable, declaracion_tipo, declaracion_proc;
non terminal  LOptParamForm lista_opt_parametros_formales;
non terminal  LParamForm lista_parametros_formales;
non terminal  ParamForm parametro_formal;
non terminal  Tipo tipo, tipo_definido, tipo_ registro, tipo_basico, T2, tipo_puntero, tipo_array;
non terminal  LParamReg lista_parametros_registro;
non terminal  ParamReg parametro_registro;
non terminal  LOptInst lista_opt_instrucciones;
non terminal  LInst lista_instrucciones;
non terminal  Inst instruccion, instruccion_eval, instruccion_if, instruccion_if_else, instruccion_while, instrucci√≥n_read, instruccion_write, instruccion_nl, instruccion_new, instruccion_delete, instruccion_call, instruccion_compuesta;
non terminal  Exp expresion, E0, E1, E2, E3, E4, E5, E6, E7;
non terminal  LOptParam lista_opt_parametros;
non terminal  LParam lista_parametros;


programa_tiny ::= bloque: blq ;
	{: RESULT = (ProgT)sem.prog_tiny(blq); :};
bloque ::= INIBLOQUE lista_opt_declaraciones: l_opt_dec lista_opt_instrucciones: l_opt_inst FINBLOQUE ;
	{: RESULT = (Blq)sem.bloque(l_opt_dec,l_opt_inst) :};

lista_opt_declaraciones ::= lista_declaraciones: l_decs FINDECLARACIONES ;
	{: RESULT = (LOptDecs)sem.si_lista_opt_decs(l_decs); :};
lista_opt_declaraciones ::= ;
	{: RESULT = (LOptDecs)sem.no_lista_opt_decs(); :};

lista_declaraciones ::= lista_declaraciones: l_decs PUNTOYCOMA declaracion: dec ;
	{: RESULT = (LDecs)sem.muchas_lista_decs(l_decs, dec); :};
lista_declaraciones ::= declaracion: dec ;
	{: RESULT = (LDecs)sem.una_lista_decs(dec); :};

declaracion ::= declaracion_variable: dec_var ;
	{: RESULT = dec_var; :};
declaracion ::= declaracion_tipo: dec_tipo ;
	{: RESULT = dec_tipo; :};
declaracion ::= declaracion_proc: dec_proc ;
	{: RESULT = dec_proc; :};

declaracion_variable ::= tipo: t Identificador: id ;
	{: RESULT = (Dec)sem.dec_var(t,id.str); :};
declaracion_tipo ::= TYPE tipo: t Identificador: id ;
	{: RESULT = (Dec)sem.dec_tipo(t,id.str()); :};
declaracion_proc ::= PROC Identificador: id INIPAR lista_opt_parametros_formales: l_opt_param_form FINPAR bloque: blq ;
	{: RESULT = (Dec)sem.dec_proc(id.str(),l_opt_param_form,blq); :};

lista_opt_parametros_formales ::= lista_parametros_formales: l_param_form ;
	{: RESULT = (LOptParamForm)sem.si_lista_opt_param_form(l_param_form); :};
lista_opt_parametros_formales ::= ;
	{: RESULT = (LOptParamForm)sem.no_lista_opt_param_form(); :};

lista_parametros_formales ::= lista_parametros_formales: l_param_form COMA parametro_formal: param_form ;
	{: RESULT = (LParamForm)sem.muchas_lista_param_form(l_param_form, param_form); :};
lista_parametros_formales ::= parametro_formal: param_form ;
	{: RESULT = (LParamForm)sem.una_lista_param_form(param_form); :};

parametro_formal ::= tipo: t REFERENCIA Identificador: id ;
	{: RESULT = (ParamForm)sem.param_form_ref(t,id.str()); :}
parametro_formal ::= tipo: t Identificador: id ;
	{: RESULT = (ParamForm)sem.param_form(t,id.str()); :}

tipo ::= tipo_array: t_arr ;
	{: RESULT = t_arr; :}
tipo_array ::= tipo_array: t_arr INIARRAY Entero: num FINARRAY ;
	{: RESULT = (Tipo)sem.tipo_array(t_arr,num.str()); :}
tipo_array ::= tipo_puntero: t_punt ;
	{: RESULT = t_punt; :}

tipo_puntero ::= PUNTERO tipo_puntero: t_punt ;
	{: RESULT = (Tipo)sem.tipo_puntero(t_punt); :}
tipo_puntero ::= T2: t2 ;
	{: RESULT = t2; :}

T2 ::= tipo_basico: t_bas ;
	{: RESULT = t_bas; :}
T2 ::= tipo_registro: t_reg ;
	{: RESULT = t_reg; :}
T2 ::= tipo_definido: t_def ;
	{: RESULT = t_def; :}

tipo_basico ::= INT ;
	{: RESULT = (Tipo)sem.int(); :}
tipo_basico ::= REAL ;
	{: RESULT = (Tipo)sem.real(); :}
tipo_basico ::= BOOL ;
	{: RESULT = (Tipo)sem.bool(); :}
tipo_basico ::= STRING ;
	{: RESULT = (Tipo)sem.string(); :}
tipo_registro ::= STRUCT INIBLOQUE lista_parametros_registro: l_param_reg FINBLOQUE ;
	{: RESULT = (Tipo)sem.tipo_registro(l_param_reg); :}
tipo_definido ::= Identificador: id ;
	{: RESULT = (Tipo)sem.tipo_definido(id.str()); :}

lista_parametros_registro ::= lista_parametros_registro: l_param_reg COMA  parametro_registro: param_reg ;
	{: RESULT = (LParamReg)sem.muchas_listas_param_reg(l_param_reg,param_reg); :}
lista_parametros_registro ::= parametro_registro: param_reg ;
	{: RESULT = (LParamReg)sem.una_lista_param_reg(param_reg); :}

parametro_registro ::= tipo: t Identificador: id ;
	{: RESULT = (ParamReg)sem.param_reg(t,id.str()); :}

lista_opt_instrucciones ::= lista_instrucciones: l_inst ;
	{: RESULT = (LOptInst)sem.si_lista_opt_inst(l_inst); :}
lista_opt_instrucciones ::= ;
	{: RESULT = (LOptInst)sem.no_lista_opt_inst; :}

lista_instrucciones ::= lista_instrucciones: l_inst PUNTOYCOMA instruccion: inst ;
	{: RESULT = (LInst)sem.muchas_lista_inst(l_inst,inst); :}
lista_instrucciones ::= instruccion: inst ;
	{: RESULT = (LInst)sem.una_lista_inst(inst); :}


instruccion ::= instruccion_eval ;
instruccion ::= instruccion_if ;
instruccion ::= instruccion_while ;
instruccion ::= instruccion_read ;
instruccion ::= instruccion_write ;
instruccion ::= instruccion_nl ;
instruccion ::= instruccion_new ;
instruccion ::= instruccion_delete ;
instruccion ::= instruccion_call ;
instruccion ::= instruccion_compuesta ;

instruccion_eval ::= ARROBA expresion ; 

expresion ::= E0 ;

E0 ::= E1 ASIGNACION E0 ;
E0 ::= E1;

E1 ::= E1 OP1 E2 ;
E1 ::= E2 ;

E2 ::= E2 MAS E3 ;
E2 ::= E3 MENOS E3 ;
E2 ::= E3 ;

E3 ::= E4 AND E3 ;
E3 ::= E4 OR E4 ;
E3 ::= E4 ;

E4 ::= E4 OP4 E5 ;
E4 ::= E5 ;

E5 ::= OP5 E5 ;
E5 ::= E6 ;

E6 ::= E6 OP6 ;
E6 ::= E7 ;

E7 ::= Entero ;
E7 ::= Real ;
E7 ::= TRUE ;
E7 ::= FALSE ;
E7 ::= NULL ;
E7 ::= Cadena ;
E7 ::= Identificador ;
E7 ::= INIPAR E0 FINPAR ;

OP1 ::= MAYOR ;
OP1 ::= MAYORIGUAL ;
OP1 ::= MENOR ;
OP1 ::= MENORIGUAL ;
OP1 ::= COMPARACION ;
OP1 ::= DISTINTO ;

OP4 ::= POR ;
OP4 ::= ENTRE ;
OP4 ::= MODULO ;

OP5 ::= NOT ;
OP5 ::= MENOS ;

OP6 ::= INIARRAY E0 FINARRAY ;
OP6 ::= PUNTO Identificador ;
OP6 ::= PUNTERO ;

instruccion_if ::= IF expresion bloque ;
instruccion_if_else ::= IF expresion bloque ELSE bloque ;
instruccion_while ::= WHILE expresion bloque ;
instruccion_read ::= READ expresion ;
instruccion_write ::= WRITE expresion ;
instruccion_nl ::= NL ;
instruccion_new ::= NEW expresion ;
instruccion_delete ::= DELETE expresion ;
instruccion_call ::= CALL Identificador parametros ;

parametros ::= INIPAR lista_opt_parametros FINPAR ;

lista_opt_parametros ::= lista_parametros ;
lista_opt_parametros ::= ;               


lista_parametros ::= lista_parametros COMA expresion ;
lista_parametros ::= expresion ;


instruccion_compuesta ::= bloque ;

